# 浏览器底层渲染机制和性能优化
## 资源加载
### css 资源加载
1. `<style>` “内嵌样式” => **同步** 交给 GUI 渲染线程解析
2. `<link>` “外链样式”
    + **异步** 开辟一个新的“HTTP网络请求线程” （根据不同的浏览器，最多只允许开辟4-7个不同的 HTTP 线程）
    + GUI 渲染线程继续向下渲染
    + GUI 渲染线程同步操作完成后，把 HTTP 请求回的文件解析渲染
3. `@import` “导入式样式”
    + **同步** 开辟一个新的“HTTP网络请求线程”
    + 在资源没有请求回来，GUI 渲染线程会被**阻塞**

### script 资源请求
+ 默认都是同步的：必须基于 HTTP 网络线程，把资源请求回来以后，交给**JS渲染线程**渲染完成后，GUI 渲染线程才能继续向下渲染
+ `<script async>` : 当资源请求一旦请求回来，中断 GUI 渲染，把请求回来的 JS 进行渲染解析
+ `<script defer>`: 和 async 类似，等 GUI 渲染线程主线程完成后，渲染 JS。

### 遇到<img>或者音频视频
+ 发送新的“HTTP 网络线程” => 等 GUI 渲染完成后，把请求回来的资源渲染

### webkit 浏览器预测解析 ：预加载扫描器 html-preload-scanner 扫描src link 等属性，找到外部链接资源进行预加载

## 页面渲染的步骤
+ DOM TREE ：自上而下，整理好整个页面的 DOM 结构关系
+ CSSOM TREE ： 把所有样式资源请求回来后，按照引入 CSS 的顺序，依次渲染样式代码，生成样式树
+ RENDER TREE ： 合并 DOM TREE 和 CSSOM TREE（display:none 不处理）
+ layout/reflow 布局/回流/重排 ： 根据生成的 RENDER TREE，计算在设备视口内的确切位置和大小
+ 分层处理：按照层级定位分层处理
+ Painting（repaint）：绘制页面

## 前端性能优化
### CRP ： 关键渲染路径 => 关键渲染路径是指浏览器通过把 HTML、CSS 和 JavaScript 转化成屏幕上的像素的步骤顺序。


+ 生成 DOM TREE
    + 减少 DOM 层级嵌套
    + 不要使用“非标准”标签
+ 生成 CSSOM TREE
    + 尽可能不要使用@import （阻塞 GUI 线程）
    + CSS 代码少，尽可能使用“style 内嵌样式”（尤其移动端）
    + 尽可能把所有样式资源合并为一个（减少HTTP请求数量，以及渲染CSS的时候，不需要计算依赖关系）
    + CSS 选择器链短一些（**CSS 选择器是从右往左**）
    + 把link等导入CSS的操作放在HEAD中（一加载页面就开始请求资源，同时GUI去生成DOM树）
+ 对于 `<img>`
    + 懒加载
    + BASE64
+ Layout/Painting：减少DOM的“回流/重排”和重绘
    + 第一次加载页面必然会有一次回流和重绘
    + 触发回流必重绘，反过来不是
    + DOM的回流
        + 元素在视口中的大小或者位置发生变化
        + 元素的删除或新增（基于 display 的显示或隐藏）
        + 视口大小发生改变
+ 渲染队列机制：在当前上下文操作中，遇到一行修改样式的代码，放在渲染队列中，接下来看是否还有修改样式的代码，如果有继续放在渲染队列中，直到没有修改样式的代码或遇到**获取样式的操作**，都会刷新渲染队列机制
    + 分离样式读写操作
    + 样式集中改变
    + 文档碎片 => createDocumentFragment()
    + 动画效果给到 position:absolute/fixed 的元素上 => 脱离文档流 单独一层
    + css 动画 => 硬件加速 不触发回流重绘
